"use strict";

var _typeof8 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof7 = typeof Symbol === "function" && _typeof8(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof8(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof8(obj);
};

var _typeof6 = typeof Symbol === "function" && _typeof7(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof7(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof7(obj);
};

var _typeof5 = typeof Symbol === "function" && _typeof6(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof6(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof6(obj);
};

var _typeof4 = typeof Symbol === "function" && _typeof5(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof5(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof5(obj);
};

var _typeof3 = typeof Symbol === "function" && _typeof4(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof4(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof4(obj);
};

var _typeof2 = typeof Symbol === "function" && _typeof3(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof3(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof3(obj);
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var COLOR_ORANGE = "#FF7F00"; //обозначение для константы
var borderLeftWidth; //в JS популярна верблюжья нотация

//-------------------------------------СТРОКИ
//"" = '', то есть в JS существует только string, char нет
// Строки в JavaScript имеют внутреннюю кодировку Юникод

//доступ к символу
var str = "jQuery";
alert(""[0]); //если символа нет, то вернёт undefined

//нельзя напрямую изменить содержимое строки (какую-то конкретную букву), можно лишь создать необходимое содержимое и присвоить в текущую

//поиск подстроки
var str = "Widget with id";

if (~str.indexOf("get")) {
  alert('совпадение есть!');
}
//Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей.
var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке
var target = "Иа"; // цель поиска

var pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert(pos);
}

//взятие подстроки
var str = "stringify";
//предпочтительнее использовать slice (см ниже)
str.substring(0, 1); // "s", символы с позиции 0 по 1 не включая последний символ (1 == t).
str.substr(2, 4); // ring, со 2-й позиции 4 символа
// если 2го аргумента нет - подразумевается, что берём все символы с позиции i до конца строки

//substring vs slice
"testme".substring(4, -1);
/* отрицательные значения приравниваются к нулю: 
    -1 становится 0 -> получили substring(4, 0)
  если start > end, то аргументы меняются местами
      4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
= >"test" */

"testme".slice(1, -1); // "estm", от 1 позиции до первой с конца.
// Отрицательные значения отсчитываются от конца строки. Это более удобно

//ПРАВИЛЬНО СРАВНЕНИЕ СТРОК (с учётом языка, а не по Unicode, где ё нет в алфавите, а "а" > "А")
var str = "Ёлки";
str.localeCompare("Яблони"); // -1
// -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны.


//узнаём тип переменной
alert(typeof COLOR_ORANGE === "undefined" ? "undefined" : _typeof(COLOR_ORANGE)); // => "string"

//-------------------------------------ПРЕОБРАЗОВАНИЯ ТИПОВ 
//ОБЫКОНОВЕННЫЙ ПЛЮС:
//если хотя бы один операнд - строка, то остальные тоже будут преобразованы в строку
alert(2 + '1'); // "21"
alert(true + "test"); // "truetest"

//ЯВНОЕ ПРЕОБРАЗОВАНИЕ ТИПА
alert(String(null) === "null"); // true,  у null слева и справа одинаковый тип данных
alert(Number("123"));
alert(Boolean(12)); //либо !!12

//остальные операторы в спорном случае приводят строку к числу
alert(2 - '1'); // 1  
alert(6 / '2'); // 3

//УНАРНЫЙ ПЛЮС
//преобразовывает значение в число
var apples = "2",
    oranges = "3";
alert(apples + oranges); // строка "23"
alert(+apples + +oranges); // число 5
alert(+"12test A"); // но если строка состоит из букв или из пробелов посередине, то NaN
// parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно
alert(parseFloat('12.3.4')); // 12.3, ошибка на второй точке
alert(parseInt('a123')); // NaN, так как до первого числа (1) были нечисловые символы

//СРАВНЕНИЕ СТРОК
//т.к посимвольно сравниваются численные коды, то необходимо приводить незвестные строки в 1 регистр
alert('Б' > 'А'); // true, но и 
alert('а' > 'Я'); // true
//=> поэтому используем .toLowerCase()

//большинство методов взаимодействия (поля форм), возвращают значения в виде строк
//поэтому, чтобы результат был правильным - преобразовываем к числу явно
alert(+"2" > +"14"); //false


//при сравнении string -> number
alert('01' == 1); // true, сравнивается как 1 == 1
//при сравнении bool -> number
alert(false == 0); //true

//СРАВНЕНИЕ РАЗНЫХ ТИПОВ
//оператор == не может отличить false от 0 и ""
//поэтому для сравнения БЕЗ ПРЕОБРАЗОВАНИЯ ТИПОВ используем ===
alert(0 === false); //если тип разный, то false


//-------------------------------------ПРИОРИТЕТ
//присваивание записывается справа налево
// var a = b = (c + 2) = 2 + 2;
//присваивание возможно внутри вычислений
// var c = 3 - (a = 3);    // => a = 3, c = 0
//++i или i++
//++i сначала увеличит переменную, и лишь затем присвоит новое значение i в "a"
a = ++i;

//-------------------------------------ОСТАТОК ОТ ДЕЛЕНИЯ 
alert(8 % 3); // 2, остаток от деления 8 на 3 ( 8 - 3*2 = 2)


//-------------------------------------ОКРУГЛЕНИЕ
alert(~~2.345); // 2 - обрезает знаки после запятой  
alert(1.1 + 1.2 ^ 0); // 2 - у ^ приоритет ниже, поэтому обрезание применяется к 2.3

Math.floor(1.1); //Округляет вниз
Math.ceil(1.1); //Округляет вверх
Math.round(1.1); //Округляет до ближайшего целого

//-------------------------------------ПРОВЕРКА НА -1
if (~str.indexOf("верка")) {/* если НЕ равно -1*/}
if (~n) {} /* если n != -1*/

//-------------------------------------ФУНКЦИЯ PROMT
/*выводит модальное окно: 
  - с заголовком (1е знач) 
  - input с placeholder (2е значение)
  - кнопками Ok/Cancel
возвращает введённую строку, если ввод отменён, то вернёт либо null, либо ""
*/
result = prompt("Как вас зовут?", "Введите ваше имя");

//-------------------------------------ФУНКЦИЯ СONFIRM
//модальное, с вопросом и кнопками ok (== true) и cancel (false)
var isAdmin = confirm("Вы - администратор?");

//-------------------------------------ФУНКЦИЯ SWITCH
var arg = prompt("Введите arg?");
switch (arg) {
  case '0':
  case '1':
    alert('Один или ноль');

  case '2':
    alert('Два');
    break;

  case 3:
    //так как prompt возвращает "3", а  не 3
    alert('Никогда не выполнится'); //как вариант, можно использовать +promt

  default:
    alert('Неизвестное значение: ' + arg);
}

//-------------------------------------ОБЛАСТЬ ВИДИМОСТИ
//переменные, объявленные внутри if/else, switch, for, while, do..while видны внутри всей функции в которой они объявлены
function count() {
  // переменные i,j не будут уничтожены по окончании цикла  
  for (var i = 0; i < 3; i++) {
    var j = i * 2;
  }

  alert(i); // i=3, последнее значение i, при нём цикл перестал работать
  alert(j); // j=4, последнее значение j, которое вычислил цикл
}

function showMessage(from, text) {
  from = '**' + from + '**'; // меняем локальную переменную from
  alert(from + ': ' + text);
}

//-------------------------------------ФУНКЦИИ: АРГУМЕНТЫ ПО УМОЛЧАНИЮ
function showMessage(from, text) {
  //если во 2й параметр ничего не передано  
  if (text === undefined) {
    /*выполняем какие-то действия, в том числе можем внутри установить значение по умолчанию*/
  }

  text = text || 'текст не передан'; //либо только устанавливаем значение по умолчанию
  //но этот способ считает, что аргумент отсутствует, если передана пустая строка, 0, или вообще любое значение, которое в логическом контексте является false
}
showMessage("Маша");

//если аргументов передано больше, то их можно считать из объекта arguments

//-------------------------------------ФУНКЦИИ: СОЗДАНИЕ АЛИАСОВ С ПОМОЩЬЮ ПЕРЕМЕННЫХ
function sayHi() {
  alert("Привет");
}

var func = sayHi; // создали алиас
func(); // Привет    

//-------------------------------------ФУНКЦИИ: АНОНИМНЫЕ ФУНКЦИИ
function ask(question, yes, no) {
  if (confirm(question)) yes();else no();
}

ask("Вы согласны?", function () {
  alert("Вы согласились.");
}, //анонимная функция №1
function () {
  alert("Вы отменили выполнение.");
} //анонимная функция №2
);

/*-------------------------------------ФУНКЦИИ: ДИНАМИЧЕСКИЕ ФУНКЦИИ
таким образом можно конструировать функцию, код которой неизвестен на момент написания программы, но строка с ним генерируется или подгружается динамически во время её выполнения.
используется, например, для динамической компиляции шаблонов на JavaScript*/
var sum = new Function('a,b', ' return a+b; ');
var result = sum(1, 2);

/*-------------------------------------ФУНКЦИИ: РЕКУРСИВНЫЕ ФУНКЦИИ
Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
Но переделка рекурсии в цикл может быть нетривиальной, особенно когда в функции, в зависимости от условий, используются различные рекурсивные подвызовы,*/

/*-------------------------------------ФУНКЦИИ: ДОКУМЕНТИРОВАНИЕ ФУНКЦИЙ
/** JSDoc синтаксис
 * Возвращает x в степени n, только для натуральных n
 *
 * @param {number} x Число для возведения в степень.
 * @param {number} n Показатель степени, натуральное число.
 * @return {number} x в степени n.
 */
function pow(x, n) {}

//-------------------------------------БАЗОВЫЕ МЕТОДЫ ДЛЯ СТАНДАРТНЫХ ТИПОВ ДАННЫХ
alert("Привет, мир!".length); // длина строки = 12
alert("Привет!".toUpperCase()); // "ПРИВЕТ!"
alert(12.345.toFixed(5)); // округляем до 5 знаков после запятой => "12.34500"
alert(isFinite(1)); // true, если это число, а не NaN/Infinity/-Infinity
//перевод данных в другую систему счисления 
//(например, чтобы «укоротить» длинный цифровой идентификатор и выдать его в url)
alert("1234567890".toString(36)); // kf12oi
Math.max(a, b, c); //наибольшее, среди аргументов
//красивое форматирование для цен, валюты, телефонных номеров и т.п.
var number = 123456789;
alert(number.toLocaleString()); // 123 456 789

//-------------------------------------НЕТОЧНЫЕ ВЫЧИСЛЕНИЯ
alert(0.1 + 0.2); // 0.30000000000000004
var result = 0.1 + 0.2;
alert(+result.toFixed(10)); // 0.3 - округления до 10 знаков обычно достаточно, чтобы избавиться от ошибки вычислений


/*-------------------------------------ОБЪЕКТЫ: КАК АССОЦИАТИВНЫЕ МАССИВЫ (словарь, хэш)*/
var person = {
  name: "Max",
  family: "Buslaev",
  skills: {
    css: 80,
    html: 70,
    js: 60
  }
}; //пример объекта

person.age = '22'; // добавили новое свойство объекту
alert(person.name + '(' + person["age"] + ") имеет навык CSS равный" + person.skills.css); //прочитали ключи нужных свойств
delete person.age; //удалили свойство из объекта

/* .name vs ['name']
  квадратные скобки позволяют:
  - использовать в качестве имени свойства любую строку:
  - обратиться к свойству, имя которого хранится в переменной*/
person['любимый стиль музыки'] = 'Джаз';
var key = 'age';
alert(person[key]);
/* Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.*/

//проверка: есть ли в объекте свойство?
if ("name" in person) {
  alert("Свойство name существует!");
}
if (person.name === undefined) {} /*свойства нет*/

/* однако, технически возможно, что свойство есть, а его значением является undefined
   поэтому во 2м способе наличие такого свойства неполучится проверить 
    var obj = {};
    obj.test = undefined; // добавили свойство со значением undefined

    alert( obj.test === undefined );      // true
    alert( obj.blabla === undefined );    // true

   Зато оператор in всегда гарантирует правильный результат*/

//сколько свойств в массиве?
var counter = 0;
for (var key in menu) {
  counter++;
}
//либо 
Object.keys(menu).length;

//обход свойств объекта
var menu = {
  width: 300,
  height: 200,
  title: "Menu"
};

for (var key in menu) {
  alert("Ключ: " + key + " значение: " + menu[key]);
}

/*порядок перебора свойств
  если имя свойства:
  - нечисловая строка, то ключ всегда перебирается в порядке присваивания
  - число или (число + строка), то свойства сортируются по порядку
*/
var user = { name: "Вася", surname: "Петров" };user.age = 25; // name, surname, age
var codes = { "7": "Россия", "38": "Украина", "1": "США" }; // 1, 7, 38

// если мы хотим избавиться от сортировки, то нужно сделать все ключи нечисловыми,
// например, добавить какой-то символ
var codes = { "+7": "Россия", "+38": "Украина", "+1": "США" };
for (var code in codes) {
  var value = codes[code];
  code = +code; // ..если нам нужно именно число, преобразуем: "+7" -> 7
  alert(code + ": " + value); // 7, 38, 1 во всех браузерах
}

/*-------------------------------------ОБЪЕКТЫ: ПЕРЕДАЧА ПО ССЫЛКЕ*/
//обычные переменные присваиваются по значению
var message = "Привет";
var phrase = message;
// => в результате 2 переменные с 2 "Привет"

//в объектах же хранятся только ссылки на переменные (свойства), которые этот объект объединяет
var user = { name: "Вася" };
var admin = user; // скопировали ссылку на вложенные переменные ( в данном случае - name)
// => теперь 2 объекта, указывающие на 1 переменную name

//при изменении этой переменной из под 1го объекта получим изменение и в другом
admin.name = 'Петя';
alert(user.name); //'Петя'

//если же всё таки нужно КЛОНИРОВАТЬ объект, чтобы изменение одного не затрагивало другой
var clone = {}; // новый пустой объект
for (var key in user) {
  clone[key] = user[key];
}
// ~: если переменная внутри объекта - тоже объект, то необходимо модернизировать до глубокого прохода

// ~: нюанс консоли для отладки в браузере 
var time = { microsecond: 123456 };

console.log(time);
time.microsecond++;

console.log(time);
time.microsecond++;

// При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения. Вывод не делает «копию» текущего содержимого, а сохраняет лишь ссылку на объект
// Поэтому будет показывать одинаковое значение


/*-------------------------------------МАССИВЫ: ОБЫКНОВЕННЫЕ
  предназначены для работы с НЕПРЕРЫВНОЙ УПОРЯДОЧЕННОЙ коллекцией,
  если элементы массива нумеруются случайно или с большими пропусками - лучше использовать объекты
*/

var fruits = ["Яблоко", "Апельсин", "Слива"]; //индексация с 0
fruits[3] = 'Лимон'; //добавили 4й элемент

// узнаём количество элементов в массиве
alert(fruits.length); // length = (last_index + 1), а НЕ количество заполненных элементов

// вывод всех элементов массива
alert(fruits); // Яблоко, Апельсин, Слива, Лимон

// в массиве могут храниться вместе абсолютно любые типы
var arr = [1, 'Имя', { name: 'Петя' }, true];

// получить объект из массива и тут же его свойство
alert(arr[2].name); // Петя

//возвращаем ПОСЛЕДНИЙ элемент, затем удаляем его из массива (быстро)
var temp = fruits.pop();

//возвращаем ПЕРВЫЙ элемент, затем удаляем его из массива (медленно - сдвигаем все элементы на 1)
var temp = fruits.shift();

//добавляем элемент/ы в конец массива   (быстро)
fruits.push("Груша");

// добавляем элемент/ы в НАЧАЛО   (медленно - сдвигаем все элементы на 1)
fruits.unshift("Абрикос", "Ананас");

// в функцию массив передаётся по ссылке, а не по значению
// поэтому функция может изменить массив
function eat(arr) {
  arr.pop();
}
// => после вызова длина массива уменьшиться

// в отличие от С необязательно присваивать новый элемент сразу после существующего
// хоть такое использование и нелогично
var fruits = [];
fruits[0] = 1;
fruits[99999] = 5;
//при выводе таких небрежно заполненных массивов вместо каждого пропущенного индекса будет выведена ,
/*=>*/alert(fruits); // 0,,,,,5


/*ПЕРЕБОР ЧИСЛОВОГО МАССИВА: for (var i=0; i<arr.length; i++) vs for (var key in arr)
  - вывести нужно значения только для элементов\свойств с числовыми индексами, но for..in выводит всё подряд. Так как многие массивы имеют дополнительные нечисловые свойства - для for..in это недостаток
  - классический цикл в 10+ раз быстрее*/

/* ЭФФЕКТИВНОЕ УДАЛЕНИЕ элементов из массива
      если уменьшить length, то элементы удалятся
      даже если вернём length обратно, то элементы не востановятся 
  ~: length = last_index + 1  */
var arr = [1, 2, 3, 4, 5];
arr.length = 2; //сократили массив до первых 2 элементов 
// => таким образом удобно очищать массив: arr.length=0;


/* ОПТИМИЗАЦИЯ ОБЫКНОВЕННЫХ МАССИВОВ    
    - хранить в массиве элементы только одного типа данных (например, только числа)
    избегать преобразования массива в объект (из непр интервала в памяти в хеш таблицы)
    - не ставить массиву произвольные свойства (arr.test = 5)
    - заполнять массив непрерывной и повозрастающей ([0], [1], [2])
*/

/*-------------------------------------МАССИВЫ: ВСТРОЕННЫЕ МЕТОДЫ*/

/* split (парсер): 
  получаем строку, по определённому разделителю дробим на элементы массива */
var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ' //разделитель (обязательно)
/* макс количество элементов, которое парсим - остальные данные отбрасываются (необяз)*/);
//=> names[0] = "Маша" ... names[3] = "Василий"

// вызов с пустой строкой разбивает по буквам
var str = "тест";
alert(str.split('')); // т,е,с,т

/* join:
   объединяет элементы массива в 1 строку*/
['Маша', 'Петя', 'Марина', 'Василий'].join(';'); //Маша;Петя;Марина;Василий


// УДАЛЕНИЕ ЭЛЕМЕНТА ИЗ МАССИВА
var arr = ["Я", "иду", "домой"];
delete arr[1];
// => ["Я", undefined, "домой"];

/* образовалась "дырка", но обычно необходимо, чтобы о элементе не осталось никаких напоминаний, а оставшиеся элементы сдвинулись на освободившийся промежуток
*/

/* splice
    умеет удалять\вставлять\заменять элементы в массиве
*/

//удалим 2 элемента, начиная с позиции 1
arr.splice(1, 2);

//удалим 4 элемента и выведем их на экран (метод возвращает их при удалении)
alert(arr.splice(2, 4));

//начиная с индекса 0, удалим 3 элемента и добавим 2 новых
arr.splice(0, 3, "А", "Б");

//ничего не удаляя, вставим новый элемент между 3м и 4м
arr.splice(2, 0, "новый");

//ничего не удаляя, вставим числа 3 и 4 перед последним элементом
arr.splice(-1, 0, 3, 4);

/*----------------------------------
        slice
  ----------------------------------
  копирует интервал [begin, end) 
  ----------------------------------*/
//создаём arr2 из arr[1], arr[2]
var arr2 = arr.slice(1, 3);

//arr3 - из всех элементов, начиная с arr[7]
var arr3 = arr.slice(7); //поэтому не указываем конец выборки

// полностью скопировать массив
var fullCopy = arr.slice();

/*----------------------------------
        sort(функция сравнения)
  ----------------------------------
  по умолчанию при сортировке преобразоывает элементы к строке, поэтому
  1, 2, 15  => 1, 15, 2
  ----------------------------------*/

//для сортировки чисел зададим функцию
function compareNumeric(a, b) {
  return a - b;
  /* > 0 - если a > b
     < 0 - если a < b
     == 0 - если равны  */
}
//передаём только название
arr.sort(compareNumeric); //=> 1, 2, 15


/*----------------------------------
      concat(новые элементы)
----------------------------------
создаёт новый массив, объединяя существующий и переданные элементы
----------------------------------*/
var arr = [1, 2];
var newArr = arr.concat(3, 4, [5, 6]);
// => 1, 2, 3, 4, 5, 6


/*----------------------------------
      indexOf(искомый элемент)
----------------------------------
возвращает индекс искомого элемента, если он есть в массиве

поиск может начинаться с конкретного индекса

работает за счёт перебора всех элементов массива (может быть медленным)
----------------------------------*/
alert(arr.indexOf(0));

//для поиска с конца есть lastIndexOf


/*----------------------------------
      Object.keys(преобразовываемый объект)
----------------------------------
создаёт массив из свойств объекта
----------------------------------*/

var user = {
  name: "Thomas",
  age: 30
};

alert(Object.keys(user)); // name, age


//*****************СОВРЕМЕННЫЕ МЕТОДЫ ДЛЯ ПЕРЕБОРА МАССИВА */

/*----------------------------------
      forEach( )
----------------------------------
item - текущий элемент массива arr
i - его индекс
----------------------------------*/
arr.forEach(function (item, i, arr) {
  alert(i + ": " + item + " (массив:" + arr + ")");
});

/*----------------------------------
      filter( )
----------------------------------
возвращает массив из тех элементов текущего, что удовлетворяют критерию
----------------------------------*/
var arr = [1, -1, 2, -2, 3];

alert(arr.filter(function (number) {
  return number > 0;
})); //1,2,3


/*----------------------------------
      map( )
----------------------------------
возвращает массив из результатов вызова определённой функции для каждого из элементов массива arr
----------------------------------*/
var names = ['HTML', 'CSS', 'JavaScript'];

alert(names.map(function (name) {
  return name.length;
})); //4, 3, 10

/*----------------------------------
      every( ), some( )
----------------------------------
методы проверки массива
every()
- return true, если callback вернёт true для КАЖДОГО элемента проверяемого arr
some()
- если для КАКОГО-НИБУДЬ элемента arr
----------------------------------*/
var arr = [1, -1, 2, -2, 3];

function isPositive(number) {
  return number > 0;
}

alert(arr.every(isPositive)); // false, не все положительные
alert(arr.some(isPositive)); // true, есть хоть одно положительное


/*----------------------------------
      reduce(
        callback(previousValue, currentItem, index, arr),
        initialValue  (необяз)
      )
----------------------------------
вычисление 1 значения на основе массива
(к каждому элементу поочерёдно примеряется callback, результат сохраняется)

currentItem
- текущий элемент, т.е. arr[index]

previousValue
- последний результат вызова функции

initialValue
- если передан, то prevValue равно ему при первом вызове, если нет - равен первому элементу массива
----------------------------------*/
var arr = [1, 2, 3];

//0 + 1 + 2 + 3
var result = arr.reduce(function (sum, current) {
  return sum + current;
}, 0 //начальное значение
);

/*************************************
 ************ПСЕВДО МАССИВ arguments***
 *************************************/

/* в JS НЕТ ПЕРЕГРУЗКИ ФУНКЦИЙ
функция может быть определена только 1 раз и вызываться может с любым количеством аргументов (даже если передано больше/меньше задуманного) */

function go(a, b) {
  alert("a=" + a + ", b=" + b);
}

go(1); // a=1, b=undefined
go(1, 2); // a=1, b=2
go(1, 2, 3); // a=1, b=2, третий аргумент не вызовет ошибку

//доступ к переданным аргументам можно получить через ОБЪЕКТ arguments и arguments.length

//это не массив, он не поддерживает методы для массивов

//но можно получить из него массив
var args = [];
for (var i = 0; i < arguments.length; i++) {
  args[i] = arguments[i];
}

/* пример использования: 
создадим copy(dst, src1, src2, ...)
-----------------------------------
объединяе свойства указанных объектов в одном */
var vasya = { age: 21, name: 'Вася' };

var user = { isAdmin: false, isEmailConfirmed: true };

var student = { university: 'My university' };

// добавить к vasya свойства из user и student
copy(vasya, user, student);

function copy() {
  var dst = arguments[0];

  for (var i = 1; i < arguments.length; i++) {
    var arg = arguments[i];
    for (var key in arg) {
      dst[key] = arg[key];
    }
  }

  return dst;
}

/***********************************
 *********ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ***** ********************************/